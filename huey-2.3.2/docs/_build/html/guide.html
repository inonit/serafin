
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Guide &#8212; huey 2.0.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Consuming Tasks" href="consumer.html" />
    <link rel="prev" title="Installing" href="installation.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="consumer.html" title="Consuming Tasks"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installing"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">huey 2.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="guide">
<span id="id1"></span><h1>Guide<a class="headerlink" href="#guide" title="Permalink to this headline">¶</a></h1>
<p>The purpose of this document is to present Huey using simple examples that
cover the most common usage of the library. Detailed documentation can be found
in the <a class="reference internal" href="api.html#api"><span class="std std-ref">API documentation</span></a>.</p>
<p>Here is a simple example of a task that accepts two numbers and returns their
sum:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># demo.py</span>
<span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">SqliteHuey</span>

<span class="n">huey</span> <span class="o">=</span> <span class="n">SqliteHuey</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;/tmp/demo.db&#39;</span><span class="p">)</span>

<span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>We can test out huey by running the consumer, specifying the import path to our
<code class="docutils literal notranslate"><span class="pre">huey</span></code> instance:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> huey_consumer.py demo.huey
</pre></div>
</div>
<p>In a separate terminal, we can use the Python shell to call our <code class="docutils literal notranslate"><span class="pre">add</span></code> task:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">demo</span> <span class="kn">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you try to resolve the result (<code class="docutils literal notranslate"><span class="pre">r</span></code>) before the task has been executed,
then <code class="docutils literal notranslate"><span class="pre">r()</span></code> will return <code class="docutils literal notranslate"><span class="pre">None</span></code>. You can avoid this by instructing the
result to block until the task has finished and a result is ready:</p>
<div class="last highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Wait up to 5 seconds for result.</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<p>Here is an explanation of what happened:</p>
<ol class="arabic simple">
<li>When the <code class="docutils literal notranslate"><span class="pre">add()</span></code> function was called, a message representing the function
call is placed in a queue.</li>
<li>The function returns immediately without actually running, and returns a
special <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object, which we can use to retrieve the result
once the task has been executed.</li>
<li>The consumer process sees that a message has arrived, and a worker will call
the <code class="docutils literal notranslate"><span class="pre">add()</span></code> function and place the return value into the result store.</li>
<li>We use the <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object to then read the return value from the
result store.</li>
</ol>
<p>For more information, see the <a class="reference internal" href="api.html#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task()</span></code></a> decorator documentation.</p>
<div class="section" id="scheduling-tasks">
<h2>Scheduling tasks<a class="headerlink" href="#scheduling-tasks" title="Permalink to this headline">¶</a></h2>
<p>Tasks can be scheduled to execute at a certain time, or after a delay. In the
following example, we will schedule a call to <code class="docutils literal notranslate"><span class="pre">add()</span></code> to run in 10 seconds,
and then will block until the result becomes available:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">schedule</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">delay</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># Will block for ~10 seconds before returning.</span>
<span class="go">7</span>
</pre></div>
</div>
<p>If we wished to schedule the task to run at a particular time, we can use the
<code class="docutils literal notranslate"><span class="pre">eta</span></code> parameter instead. The following example will also be run after a 10
second delay:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eta</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">schedule</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># Will block for ~10 seconds.</span>
<span class="go">9</span>
</pre></div>
</div>
<p>Here is an explanation of what happened:</p>
<ol class="arabic simple">
<li>When we call the <a class="reference internal" href="api.html#TaskWrapper.schedule" title="TaskWrapper.schedule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">schedule()</span></code></a> method, a message
representing the function call (including details about when the function
should be scheduled) is placed in the queue.</li>
<li>The function returns immediately without actually running, and returns a
special <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object, which we can use to retrieve the result
once the task has been executed.</li>
<li>The consumer process sees that a message has arrived, and will notice that
the message is not yet ready to be executed, but should be run in ~10s.</li>
<li>The consumer adds the message to a schedule.</li>
<li>In ~10 seconds, the scheduler will pick-up the message and place it back
into the queue for execution.</li>
<li>A worker will dequeue the message and this time it is ready to execute, so
the function will be called and the result placed in the result store.</li>
<li>The <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object from step 2 will now be able to read the
return value from the task.</li>
</ol>
<p>For more details, see the <a class="reference internal" href="api.html#TaskWrapper.schedule" title="TaskWrapper.schedule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">schedule()</span></code></a> API documentation.</p>
</div>
<div class="section" id="periodic-tasks">
<h2>Periodic tasks<a class="headerlink" href="#periodic-tasks" title="Permalink to this headline">¶</a></h2>
<p>Huey provides crontab-like functionality that enables functions to be executed
automatically on a given schedule. In this example we will declare a periodic
task that executes every 3 minutes and prints a message in the consumer process
stdout:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">SqliteHuey</span>
<span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">crontab</span>

<span class="n">huey</span> <span class="o">=</span> <span class="n">SqliteHuey</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;/tmp/demo.db&#39;</span><span class="p">)</span>

<span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="nd">@huey.periodic_task</span><span class="p">(</span><span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s1">&#39;*/3&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">every_three_minutes</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;This task runs every three minutes&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The same scheduler that handles enqueueing tasks which are scheduled to run in
the future also handles enqueueing periodic tasks. Once a minute, the scheduler
will check to see if any of the periodic tasks should be called, and if so will
place a message on the queue, instructing the next available worker to run the
function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because periodic tasks are called independent of any user interaction, they
should not accept any parameters.</p>
</div>
<p>Similarly, the return-value for a periodic task is discarded, rather than being
put into the result store. The reason for this is because there would not be an
obvious way for an application to obtain a <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> handle to access
the result of a given periodic task execution.</p>
<p>The <a class="reference internal" href="api.html#crontab" title="crontab"><code class="xref py py-func docutils literal notranslate"><span class="pre">crontab()</span></code></a> function accepts the following arguments:</p>
<ul class="simple">
<li>minute</li>
<li>hour</li>
<li>day</li>
<li>month</li>
<li>day_of_week (0=Sunday, 6=Saturday)</li>
</ul>
<p>Acceptable inputs:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">*</span></code> - always true, e.g. if <code class="docutils literal notranslate"><span class="pre">hour='*'</span></code>, then the rule matches any hour.</li>
<li><code class="docutils literal notranslate"><span class="pre">*/n</span></code> - every <em>n</em> interval, e.g. <code class="docutils literal notranslate"><span class="pre">minute='*/15'</span></code> means every 15 minutes.</li>
<li><code class="docutils literal notranslate"><span class="pre">m-n</span></code> - run every time <code class="docutils literal notranslate"><span class="pre">m..n</span></code> inclusive.</li>
<li><code class="docutils literal notranslate"><span class="pre">m,n</span></code> - run on <em>m</em> and <em>n</em>.</li>
</ul>
<p>Multiple rules can be expressed by separating the individual rules with a
comma, for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Runs every 10 minutes between 9a and 11a, and 4p-6p.</span>
<span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s1">&#39;*/10&#39;</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="s1">&#39;9-11,16-18&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information see the following API documentation:</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#Huey.periodic_task" title="Huey.periodic_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">periodic_task()</span></code></a></li>
<li><a class="reference internal" href="api.html#crontab" title="crontab"><code class="xref py py-func docutils literal notranslate"><span class="pre">crontab()</span></code></a></li>
</ul>
</div>
<div class="section" id="retrying-tasks-that-fail">
<h2>Retrying tasks that fail<a class="headerlink" href="#retrying-tasks-that-fail" title="Permalink to this headline">¶</a></h2>
<p>Sometimes we may have a task that we anticipate might fail from time to time,
in which case we should retry it. Huey supports automatically retrying tasks a
given number of times, optionally with a delay between attempts.</p>
<p>Here we’ll declare a task that fails approximately half of the time. To
configure this task to be automatically retried, use the <code class="docutils literal notranslate"><span class="pre">retries</span></code> parameter
of the <a class="reference internal" href="api.html#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task()</span></code></a> decorator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="nd">@huey.task</span><span class="p">(</span><span class="n">retries</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Retry the task up to 2 times.</span>
<span class="k">def</span> <span class="nf">flaky_task</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;failing!&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;OK&#39;</span>
</pre></div>
</div>
<p>Here is what might happen behind-the-scenes if we call this task:</p>
<ol class="arabic simple">
<li>Message is placed on the queue indicating that our task should be called,
just like usual, and a <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> handle is returned to the caller.</li>
<li>Consumer picks up the message and attempts to run the task, but the call to
<code class="docutils literal notranslate"><span class="pre">random.randint()</span></code> happened to return <code class="docutils literal notranslate"><span class="pre">0</span></code>, so an exception is raised.</li>
<li>The consumer puts the error into the result store and the exception is
logged. If the caller resolves the <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> now, a
<a class="reference internal" href="api.html#TaskException" title="TaskException"><code class="xref py py-class docutils literal notranslate"><span class="pre">TaskException</span></code></a> will be raised which contains information about
the exception that occurred in our task.</li>
<li>The consumer notices that the task can be retried 2 times, so it decrements
the retry count and re-enqueues it for execution.</li>
<li>The consumer picks up the message again and runs the task. This time, the
task succeeds! The new return value is placed into the result store (“OK”).</li>
<li>We can reset our <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> wrapper by calling
<a class="reference internal" href="api.html#Result.reset" title="Result.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> and then re-resolve it. The result object will now
give us the new value, “OK”.</li>
</ol>
<p>Should the task fail on the first invocation, it will be retried up-to two
times. Note that it will be retried <em>immediately</em> after it returns.</p>
<p>To specify a delay between retry attempts, we can add a <code class="docutils literal notranslate"><span class="pre">retry_delay</span></code>
argument. The task will be retried up-to two times, with a delay of 10 seconds
between attempts:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.task</span><span class="p">(</span><span class="n">retries</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">retry_delay</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flaky_task</span><span class="p">():</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Retries and retry delay arguments can also be specified for periodic tasks.</p>
</div>
<p>It is also possible to explicitly retry a task from within the task, by raising
a <a class="reference internal" href="api.html#RetryTask" title="RetryTask"><code class="xref py py-class docutils literal notranslate"><span class="pre">RetryTask</span></code></a> exception. When this exception is used, the task will
be retried regardless of whether it was declared with <code class="docutils literal notranslate"><span class="pre">retries</span></code>. Similarly,
the task’s remaining retries (if they were declared) will not be affected by
raising <a class="reference internal" href="api.html#RetryTask" title="RetryTask"><code class="xref py py-class docutils literal notranslate"><span class="pre">RetryTask</span></code></a>.</p>
<p>For more information, see the following API documentation:</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task()</span></code></a> and <a class="reference internal" href="api.html#Huey.periodic_task" title="Huey.periodic_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">periodic_task()</span></code></a></li>
<li><a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a></li>
</ul>
</div>
<div class="section" id="canceling-or-pausing-tasks">
<h2>Canceling or pausing tasks<a class="headerlink" href="#canceling-or-pausing-tasks" title="Permalink to this headline">¶</a></h2>
<p>Huey can dynamically cancel tasks from executing at runtime. This applies to
regular tasks, tasks scheduled to execute in the future, and periodic tasks.</p>
<p>Any task can be canceled (“revoked”), provided the task is not being executed
by the consumer. Similarly, a revoked task can be restored, provided it has not
already been processed and discarded by the consumer. To do this we will use
the <a class="reference internal" href="api.html#Result.revoke" title="Result.revoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.revoke()</span></code></a> and <a class="reference internal" href="api.html#Result.restore" title="Result.restore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.restore()</span></code></a> methods:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Schedule a task to execute in 60 seconds.</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">schedule</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">delay</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># Provided the 60s has not elapsed, the task can be canceled</span>
<span class="c1"># by calling the `revoke()` method on the result object.</span>
<span class="n">res</span><span class="o">.</span><span class="n">revoke</span><span class="p">()</span>

<span class="c1"># We can check to see if the task is revoked.</span>
<span class="n">res</span><span class="o">.</span><span class="n">is_revoked</span><span class="p">()</span>  <span class="c1"># -&gt; True</span>

<span class="c1"># Similarly, we can restore the task, provided the 60s has</span>
<span class="c1"># not elapsed (at which point it would have been read and</span>
<span class="c1"># discarded by the consumer).</span>
<span class="n">res</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
</pre></div>
</div>
<p>To revoke <em>all</em> instances of a given task, use the
<a class="reference internal" href="api.html#TaskWrapper.revoke" title="TaskWrapper.revoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">revoke()</span></code></a> and <a class="reference internal" href="api.html#TaskWrapper.restore" title="TaskWrapper.restore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restore()</span></code></a> methods on
the task function itself:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Prevent all instances of the add() task from running.</span>
<span class="n">add</span><span class="o">.</span><span class="n">revoke</span><span class="p">()</span>

<span class="c1"># We can check to see that all instances of the add() task</span>
<span class="c1"># are revoked:</span>
<span class="n">add</span><span class="o">.</span><span class="n">is_revoked</span><span class="p">()</span>  <span class="c1"># -&gt; True</span>

<span class="c1"># We can enqueue an instance of the add task, and then check</span>
<span class="c1"># to verify that it is revoked:</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">res</span><span class="o">.</span><span class="n">is_revoked</span><span class="p">()</span>  <span class="c1"># -&gt; True</span>

<span class="c1"># To re-enable a task, we&#39;ll use the restore() method on</span>
<span class="c1"># the task function:</span>
<span class="n">add</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>

<span class="c1"># Is the add() task enabled again?</span>
<span class="n">add</span><span class="o">.</span><span class="n">is_revoked</span><span class="p">()</span>  <span class="c1"># -&gt; False</span>
</pre></div>
</div>
<p>So as you can see, Huey provides APIs to control revoke / restore on both
individual instances of a task, as well as all instances of the task. For more
information, see the following API docs:</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#Result.revoke" title="Result.revoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.revoke()</span></code></a> and <a class="reference internal" href="api.html#Result.restore" title="Result.restore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.restore()</span></code></a> for revoking
individual instances of a task.</li>
<li><a class="reference internal" href="api.html#Result.is_revoked" title="Result.is_revoked"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.is_revoked()</span></code></a> for checking the status of a task instance.</li>
<li><a class="reference internal" href="api.html#TaskWrapper.revoke" title="TaskWrapper.revoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TaskWrapper.revoke()</span></code></a> and <a class="reference internal" href="api.html#TaskWrapper.restore" title="TaskWrapper.restore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TaskWrapper.restore()</span></code></a> for revoking
all instances of a task.</li>
<li><a class="reference internal" href="api.html#TaskWrapper.is_revoked" title="TaskWrapper.is_revoked"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TaskWrapper.is_revoked()</span></code></a> for checking the status of the task
function itself.</li>
</ul>
</div>
<div class="section" id="canceling-or-pausing-periodic-tasks">
<h2>Canceling or pausing periodic tasks<a class="headerlink" href="#canceling-or-pausing-periodic-tasks" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">revoke()</span></code> and <code class="docutils literal notranslate"><span class="pre">restore()</span></code> methods support some additional options
which may be especially useful when used with <a class="reference internal" href="api.html#Huey.periodic_task" title="Huey.periodic_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">periodic_task()</span></code></a>.</p>
<p>The <a class="reference internal" href="api.html#TaskWrapper.revoke" title="TaskWrapper.revoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">revoke()</span></code></a> method accepts two optional parameters:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">revoke_once</span></code> - boolean flag, if set then only the next occurrence of the
task will be revoked, after which it will be restored automatically.</li>
<li><code class="docutils literal notranslate"><span class="pre">revoke_until</span></code> - datetime, which specifies the time at which the task
should be automatically restored.</li>
</ul>
<p>For example, suppose we have a task that sends email notifications, but our
mail server goes down and won’t be fixed for a while. We can revoke the task
for a couple of hours, after which time it will start executing again:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.periodic_task</span><span class="p">(</span><span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">send_notification_emails</span><span class="p">():</span>
    <span class="c1"># ... code to send emails ...</span>
</pre></div>
</div>
<p>Here is how we might revoke the task for the next 3 hours:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">send_notification_emails</span><span class="o">.</span><span class="n">revoke</span><span class="p">(</span><span class="n">revoke_until</span><span class="o">=</span><span class="n">eta</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, we could use <code class="docutils literal notranslate"><span class="pre">revoke_once=True</span></code> to just skip the next
execution of the task:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">send_notification_emails</span><span class="o">.</span><span class="n">revoke</span><span class="p">(</span><span class="n">revoke_once</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>At any time, the task can be restored using the usual
<a class="reference internal" href="api.html#TaskWrapper.restore" title="TaskWrapper.restore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restore()</span></code></a> method, and it’s status can be checked using
the <a class="reference internal" href="api.html#TaskWrapper.is_revoked" title="TaskWrapper.is_revoked"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_revoked()</span></code></a> method.</p>
</div>
<div class="section" id="task-pipelines">
<h2>Task pipelines<a class="headerlink" href="#task-pipelines" title="Permalink to this headline">¶</a></h2>
<p>Huey supports pipelines (or chains) of one or more tasks that should be
executed sequentially.</p>
<p>To get started, I’ll just review the usual method of running a task:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>A slightly more verbose way of writing that would be to use the
<a class="reference internal" href="api.html#TaskWrapper.s" title="TaskWrapper.s"><code class="xref py py-meth docutils literal notranslate"><span class="pre">s()</span></code></a> method to create a <a class="reference internal" href="api.html#Task" title="Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> instance and then
enqueue it explicitly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a task representing the execution of add(1, 2).</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Enqueue the task instance, which returns a Result handle.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">huey</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>
</div>
<p>So the following are equivalent:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># And:</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">huey</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">add</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="api.html#TaskWrapper.s" title="TaskWrapper.s"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TaskWrapper.s()</span></code></a> method is used to create a <a class="reference internal" href="api.html#Task" title="Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>
instance, which represents the execution of the given function. The
<code class="docutils literal notranslate"><span class="pre">Task</span></code> is what gets serialized and enqueued, then dequeued, deserialized and
executed by the consumer.</p>
<p>To create a pipeline, we will use the <a class="reference internal" href="api.html#TaskWrapper.s" title="TaskWrapper.s"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TaskWrapper.s()</span></code></a> method to create
a <a class="reference internal" href="api.html#Task" title="Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> instance. We can then chain additional tasks using the
<a class="reference internal" href="api.html#Task.then" title="Task.then"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.then()</span></code></a> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add_task</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Create Task to represent add(1, 2) invocation.</span>

<span class="c1"># Add additional tasks to pipeline by calling add_task.then().</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="p">(</span><span class="n">add_task</span>
            <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># Call add() with previous result (1+2) and 3.</span>
            <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># Previous result ((1+2)+3) and 4.</span>
            <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="c1"># Etc.</span>

<span class="c1"># When a pipeline is enqueued, a ResultGroup is returned (which is</span>
<span class="c1"># comprised of individual Result instances).</span>
<span class="n">result_group</span> <span class="o">=</span> <span class="n">huey</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">pipeline</span><span class="p">)</span>

<span class="c1"># Print results of above pipeline.</span>
<span class="k">print</span><span class="p">(</span><span class="n">result_group</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="c1"># [3, 6, 10, 15]</span>

<span class="c1"># Alternatively, we could have iterated over the result group:</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">result_group</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="c1"># 3</span>
<span class="c1"># 6</span>
<span class="c1"># 10</span>
<span class="c1"># 15</span>
</pre></div>
</div>
<p>When enqueueing a task pipeline, the return value will be a
<a class="reference internal" href="api.html#ResultGroup" title="ResultGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultGroup</span></code></a>, which encapsulates the <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> objects for
the individual task invocations. <a class="reference internal" href="api.html#ResultGroup" title="ResultGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultGroup</span></code></a> can be iterated over
to yield individual <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> items, or you can use the
<a class="reference internal" href="api.html#ResultGroup.get" title="ResultGroup.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResultGroup.get()</span></code></a> method to get all the task return values as a list.</p>
<p>Note that the return value from the parent task is passed to the next task in
the pipeline, and so on.</p>
<p>If the value returned by the parent function is a <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, then the tuple
will be used to extend the <code class="docutils literal notranslate"><span class="pre">*args</span></code> for the next task.  Likewise, if the
parent function returns a <code class="docutils literal notranslate"><span class="pre">dict</span></code>, then the dict will be used to update the
<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> for the next task.</p>
<p>Example of chaining fibonacci calculations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># returns tuple, which is passed as *args</span>

<span class="n">pipe</span> <span class="o">=</span> <span class="p">(</span><span class="n">fib</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
        <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
        <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">fib</span><span class="p">))</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">huey</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">results</span><span class="p">(</span><span class="bp">True</span><span class="p">))</span>  <span class="c1"># Resolve results, blocking until all are finished.</span>
<span class="c1"># [(2, 1), (3, 2), (5, 3), (8, 5)]</span>
</pre></div>
</div>
<p>For more information, see the following API docs:</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#TaskWrapper.s" title="TaskWrapper.s"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TaskWrapper.s()</span></code></a></li>
<li><a class="reference internal" href="api.html#Task.then" title="Task.then"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.then()</span></code></a></li>
<li><a class="reference internal" href="api.html#ResultGroup" title="ResultGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultGroup</span></code></a> and <a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a></li>
</ul>
</div>
<div class="section" id="locking-tasks">
<h2>Locking tasks<a class="headerlink" href="#locking-tasks" title="Permalink to this headline">¶</a></h2>
<p>Task locking can be accomplished using the <a class="reference internal" href="api.html#Huey.lock_task" title="Huey.lock_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Huey.lock_task()</span></code></a> method,
which acts can be used as a context-manager or decorator.</p>
<p>This lock is designed to be used to prevent multiple invocations of a task from
running concurrently. If using the lock as a decorator, place it directly above
the function declaration.</p>
<p>If a second invocation occurs and the lock cannot be acquired, then a special
<code class="xref py py-class docutils literal notranslate"><span class="pre">TaskLockedException</span></code> is raised and the task will not be executed.
If the task is configured to be retried, then it will be retried normally, but
the failure to acquire the lock is not considered an error.</p>
<p>Examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.periodic_task</span><span class="p">(</span><span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s1">&#39;*/5&#39;</span><span class="p">))</span>
<span class="nd">@huey.lock_task</span><span class="p">(</span><span class="s1">&#39;reports-lock&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">generate_report</span><span class="p">():</span>
    <span class="c1"># If a report takes longer than 5 minutes to generate, we do</span>
    <span class="c1"># not want to kick off another until the previous invocation</span>
    <span class="c1"># has finished.</span>
    <span class="n">run_report</span><span class="p">()</span>


<span class="nd">@huey.periodic_task</span><span class="p">(</span><span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">backup</span><span class="p">():</span>
    <span class="c1"># Generate backup of code</span>
    <span class="n">do_code_backup</span><span class="p">()</span>

    <span class="c1"># Generate database backup. Since this may take longer than an</span>
    <span class="c1"># hour, we want to ensure that it is not run concurrently.</span>
    <span class="k">with</span> <span class="n">huey</span><span class="o">.</span><span class="n">lock_task</span><span class="p">(</span><span class="s1">&#39;db-backup&#39;</span><span class="p">):</span>
        <span class="n">do_db_backup</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="signals">
<h2>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code> will send <a class="reference internal" href="signals.html#signals"><span class="std std-ref">signals</span></a> as it moves through
various stages of its operations. The <a class="reference internal" href="api.html#Huey.signal" title="Huey.signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Huey.signal()</span></code></a> method can be used
to attach a callback to one or more signals, which will be invoked
synchronously by the consumer when the signal is sent.</p>
<p>For a simple example, we can add a signal handler that simply prints the signal
name and the ID of the related task.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.signal</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">print_signal_args</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">signal</span> <span class="o">==</span> <span class="n">SIGNAL_ERROR</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> - </span><span class="si">%s</span><span class="s1"> - exception: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> - </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="api.html#Huey.signal" title="Huey.signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">signal()</span></code></a> method is used to decorate the signal-handling
function. It accepts an optional list of signals. If none are provided, as in
our example, then the handler will be called for any signal.</p>
<p>The callback function (<code class="docutils literal notranslate"><span class="pre">print_signal_args</span></code>) accepts two required arguments,
which are present on every signal: <code class="docutils literal notranslate"><span class="pre">signal</span></code> and <code class="docutils literal notranslate"><span class="pre">task</span></code>. Additionally, our
handler accepts an optional third argument <code class="docutils literal notranslate"><span class="pre">exc</span></code> which is only included with
<code class="docutils literal notranslate"><span class="pre">SIGNAL_ERROR</span></code>. <code class="docutils literal notranslate"><span class="pre">SIGNAL_ERROR</span></code> is only sent when a task raises an uncaught
exception during execution.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Signal handlers are executed <em>synchronously</em> by the consumer, so it is
typically a bad idea to introduce any slow operations into a signal
handler.</p>
</div>
<p>For a complete list of Huey’s signals and their meaning, see the <a class="reference internal" href="signals.html#signals"><span class="std std-ref">Signals</span></a>
document, and the <a class="reference internal" href="api.html#Huey.signal" title="Huey.signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Huey.signal()</span></code></a> API documentation.</p>
</div>
<div class="section" id="immediate-mode">
<span id="immediate"></span><h2>Immediate mode<a class="headerlink" href="#immediate-mode" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Immediate mode replaces the <em>always eager</em> mode available prior to the
release of Huey 2. It offers many improvements over always eager mode,
which are described in the <a class="reference internal" href="changes.html#changes"><span class="std std-ref">Changes in 2.0</span></a> document.</p>
</div>
<p>Huey can be run in a special mode called <em>immediate</em> mode, which is very useful
during testing and development. In immediate mode, Huey will execute task
functions immediately rather than enqueueing them, while still preserving the
APIs and behaviors one would expect when running a dedicated consumer process.</p>
<p>Immediate mode can be enabled in two ways:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">huey</span> <span class="o">=</span> <span class="n">RedisHuey</span><span class="p">(</span><span class="s1">&#39;my-app&#39;</span><span class="p">,</span> <span class="n">immediate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Or at any time, via the &quot;immediate&quot; attribute:</span>
<span class="n">huey</span> <span class="o">=</span> <span class="n">RedisHuey</span><span class="p">(</span><span class="s1">&#39;my-app&#39;</span><span class="p">)</span>
<span class="n">huey</span><span class="o">.</span><span class="n">immediate</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>To disable immediate mode:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">huey</span><span class="o">.</span><span class="n">immediate</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>
</div>
<p>By default, enabling immediate mode will switch your Huey instance to using
in-memory storage. This is to prevent accidentally reading or writing to live
storage while doing development or testing. If you prefer to use immediate mode
with live storage, you can specify <code class="docutils literal notranslate"><span class="pre">immediate_use_memory=False</span></code> when creating
your <a class="reference internal" href="api.html#Huey" title="Huey"><code class="xref py py-class docutils literal notranslate"><span class="pre">Huey</span></code></a> instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">huey</span> <span class="o">=</span> <span class="n">RedisHuey</span><span class="p">(</span><span class="s1">&#39;my-app&#39;</span><span class="p">,</span> <span class="n">immediate_use_memory</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>You can try out immediate mode quite easily in the Python shell. In the
following example, everything happens within the interpreter – no separate
consumer process is needed. In fact, because immediate mode switches to an
in-memory storage when enabled, we don’t even have to be running a Redis
server:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">RedisHuey</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">huey</span> <span class="o">=</span> <span class="n">RedisHuey</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">huey</span><span class="o">.</span><span class="n">immediate</span> <span class="o">=</span> <span class="bp">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nd">@huey.task</span><span class="p">()</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">()</span>
<span class="go">3</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="o">.</span><span class="n">revoke</span><span class="p">(</span><span class="n">revoke_once</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># We can revoke tasks.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)()</span>  <span class="c1"># No longer revoked, was restored automatically.</span>
<span class="go">7</span>
</pre></div>
</div>
<p>What happens if we try to schedule a task for execution in the future, while
using immediate mode?</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">schedule</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">delay</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="c1"># No result.</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As you can see, the task was not executed. So what happened to it? The answer
is that the task was added to the in-memory storage layer’s schedule. We can
check this by calling <a class="reference internal" href="api.html#Huey.scheduled" title="Huey.scheduled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Huey.scheduled()</span></code></a>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">huey</span><span class="o">.</span><span class="n">scheduled</span><span class="p">()</span>
<span class="go">[__main__.add: 8873...bcbd @2019-03-27 02:50:06]</span>
</pre></div>
</div>
<p>Since immediate mode is fully synchronous, there is not a separate thread
monitoring the schedule. The schedule can still be read or written to, but
scheduled tasks will not automatically be executed.</p>
</div>
<div class="section" id="tips-and-tricks">
<h2>Tips and tricks<a class="headerlink" href="#tips-and-tricks" title="Permalink to this headline">¶</a></h2>
<p>To call a task-decorated function in its original form, you can use
<a class="reference internal" href="api.html#TaskWrapper.call_local" title="TaskWrapper.call_local"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_local()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Call the add() function in &quot;un-decorated&quot; form, skipping all</span>
<span class="c1"># the huey stuff:</span>
<span class="n">add</span><span class="o">.</span><span class="n">call_local</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># Returns 7.</span>
</pre></div>
</div>
<p>It’s also worth mentioning that python decorators are just syntactical sugar
for wrapping a function with another function. Thus, the following two examples
are equivalent:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Equivalent to:</span>
<span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">add</span> <span class="o">=</span> <span class="n">huey</span><span class="o">.</span><span class="n">task</span><span class="p">()(</span><span class="n">_add</span><span class="p">)</span>
</pre></div>
</div>
<p>Task functions can be applied multiple times to a list (or iterable) of
parameters using the <a class="reference internal" href="api.html#TaskWrapper.map" title="TaskWrapper.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a> method:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@huey.task</span><span class="p">()</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result_group</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result_group</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[0, 2, 6, 12, 20, 30, 42, 56, 72, 90]</span>
</pre></div>
</div>
<p>The Huey result-store can be used directly if you need a convenient way to
cache arbitrary key/value data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">calculate_something</span><span class="p">():</span>
    <span class="c1"># By default, the result store treats get() like a pop(), so in</span>
    <span class="c1"># order to preserve the data so it can be read again, we specify</span>
    <span class="c1"># the second argument, peek=True.</span>
    <span class="n">prev_results</span> <span class="o">=</span> <span class="n">huey</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;calculate-something.result&#39;</span><span class="p">,</span> <span class="n">peek</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prev_results</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># No previous results found, start from the beginning.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">start_from_beginning</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Only calculate what has changed since last time.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">just_what_changed</span><span class="p">(</span><span class="n">prev_results</span><span class="p">)</span>

    <span class="c1"># We can store the updated data back in the result store.</span>
    <span class="n">huey</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;calculate-something.result&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="api.html#Huey.get" title="Huey.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Huey.get()</span></code></a> and <a class="reference internal" href="api.html#Huey.put" title="Huey.put"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Huey.put()</span></code></a> for additional details.</p>
</div>
<div class="section" id="reading-more">
<h2>Reading more<a class="headerlink" href="#reading-more" title="Permalink to this headline">¶</a></h2>
<p>That sums up the basic usage patterns of huey. Below are links for details on
other aspects of the APIs:</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#Huey" title="Huey"><code class="xref py py-class docutils literal notranslate"><span class="pre">Huey</span></code></a> - responsible for coordinating executable tasks and queue
backends</li>
<li><a class="reference internal" href="api.html#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Huey.task()</span></code></a> - decorator to indicate an executable task.</li>
<li><a class="reference internal" href="api.html#Result" title="Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> - handle for interacting with a task.</li>
<li><a class="reference internal" href="api.html#Huey.periodic_task" title="Huey.periodic_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Huey.periodic_task()</span></code></a> - decorator to indicate a task that executes at
periodic intervals.</li>
<li><a class="reference internal" href="api.html#crontab" title="crontab"><code class="xref py py-func docutils literal notranslate"><span class="pre">crontab()</span></code></a> - define what intervals to execute a periodic command.</li>
<li>For information about managing shared resources like database connections,
refer to the <a class="reference internal" href="shared_resources.html#shared-resources"><span class="std std-ref">shared resources</span></a> document.</li>
</ul>
<p>Also check out the <a class="reference internal" href="consumer.html#consuming-tasks"><span class="std std-ref">notes on running the consumer</span></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Guide</a><ul>
<li><a class="reference internal" href="#scheduling-tasks">Scheduling tasks</a></li>
<li><a class="reference internal" href="#periodic-tasks">Periodic tasks</a></li>
<li><a class="reference internal" href="#retrying-tasks-that-fail">Retrying tasks that fail</a></li>
<li><a class="reference internal" href="#canceling-or-pausing-tasks">Canceling or pausing tasks</a></li>
<li><a class="reference internal" href="#canceling-or-pausing-periodic-tasks">Canceling or pausing periodic tasks</a></li>
<li><a class="reference internal" href="#task-pipelines">Task pipelines</a></li>
<li><a class="reference internal" href="#locking-tasks">Locking tasks</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
<li><a class="reference internal" href="#immediate-mode">Immediate mode</a></li>
<li><a class="reference internal" href="#tips-and-tricks">Tips and tricks</a></li>
<li><a class="reference internal" href="#reading-more">Reading more</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Installing</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="consumer.html"
                        title="next chapter">Consuming Tasks</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/guide.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="consumer.html" title="Consuming Tasks"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installing"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">huey 2.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013, charles leifer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.
    </div>
  </body>
</html>